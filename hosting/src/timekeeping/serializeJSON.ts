/*
 * Serializes an Enduro to and from our JSON storage format.
 * DANGER: JSON member names in this file are serialized so don't change
 * them ,doing so will break any previously stored data.
 */
import {
  SpeedChange, Reset, ResetTo0,
  GasStop, Known, Note, Start, End,
  FreeTime, FreeZone, Action, ActionType
} from './actions';
import RouteSheet, { RouteSheetOptions } from './routesheet'
import Enduro from './enduro'
const debug = console.log

const ACTIONS_TO_JSON = new Map<any, (json, action:any) => void>([
  [SpeedChange, (json, action) => json.speed =      action.speed],
  [FreeTime,    (json, action) => json.minutes =    action.freeTime],
  [Note,        (json, action) => json.note =       action.note],
  [Reset,       (json, action) => json.toDistance = action.to],
  [FreeZone,    (json, action) => json.toDistance = action.to]
])

/**
 * Converts an enduro into a plain JSON object that is serializable across the
 * API or to disk or database.
 *
 * @param enduro Enduro to serialize
 * @return Plain JSON representation of Enduro
 */
function toJSON_2(enduro:Enduro) {
  const routeSheet:RouteSheet = enduro.routeSheet
  const result = {
    version: "2",
    title: enduro.title,
    routeSheet: {
      keyTime: routeSheet.getKeyTime(),
      actions: [] as any[],
      options: routeSheet.options
    }
  }

  for (const action of routeSheet.actions()) {
    const jsonAction:any = {
      type: action.type,
      distance: action.distance
    }

    const mapping = ACTIONS_TO_JSON.get(action.constructor)
    if (mapping) {
      mapping(jsonAction, action)
    }
    result.routeSheet.actions.push(jsonAction)
  }

  return result
}

/**
 * Converts a plain JSON object created by toJSON back into a Enduro.
 *
 * @param json JSON object generated by toJSON
 */
function fromJSON_2(json): Enduro {
  /**
   * Maps ActionType to a function that instantiates a new instance of the
   * correct Action class.
   */
  const FROM_JSON_MAP:{[index:string]: (a:any) => Action} = {
    [ActionType.SpeedChange]: (a) => new SpeedChange(a.distance, a.speed),
    [ActionType.FreeTime]:    (a) => new FreeTime(a.distance, a.minutes),
    [ActionType.Note]:        (a) => new Note(a.distance, a.note),
    [ActionType.GasStop]:     (a) => new GasStop(a.distance),
    [ActionType.Reset]:       (a) => new Reset(a.distance, a.toDistance),
    [ActionType.FreeZone]:    (a) => new FreeZone(a.distance, a.toDistance),
    [ActionType.ResetToZero]: (a) => new ResetTo0(a.distance),
    [ActionType.Known]:       (a) => new Known(a.distance),
    [ActionType.Start]:       (a) => new Start(a.distance),
    [ActionType.End]:         (a) => new End(a.distance),
  }

  const enduro = new Enduro()
  enduro.title = json?.title ?? ''

  if (json.routeSheet && json.routeSheet.actions.length) {
    console.assert(json.version === "2")
    const jsonRS = json.routeSheet
    // Use first action's speed (must be a speed change)
    const initialSpeed = jsonRS.actions[0] && jsonRS.actions[0].speed || 18;
    (enduro.routeSheet.get(0) as SpeedChange).speed = initialSpeed

    enduro.routeSheet.options = json?.routeSheet?.options ?? {secretMinSpeed: 6, useSecretMinSpeed: false}

    if (jsonRS.keyTime) {
      enduro.routeSheet.setKeyTime(jsonRS.keyTime);
    }
    for (let action of jsonRS.actions) {
      // First action was passed to constructor so we skip it here.
      if (action === jsonRS.actions[0]) { continue }


      const mapEntry = FROM_JSON_MAP[action.type]
      if (!mapEntry) {
        const message = `Unknown JSON action type ${action.type} - skipping`
        debug(message)
        throw new Error(message)
      }
      enduro.routeSheet.appendAction(mapEntry(action))
    }
  }

  return enduro;
}

interface v1Type {
  speed?: boolean
  freeTime?: boolean
  note?: boolean
  gasStop?: boolean
  reset?: boolean
  freeZone?: boolean
  resetTo0?: boolean
  known?: boolean
  start?: boolean
  end?: boolean
}
interface v1Action {
  type: v1Type
  distance: number
  speed?: number
  note?: string | null
  toDistance?: number
  minutes?: number
}

interface v1Route {
  title: string
  keyTime: number
  options: RouteSheetOptions
  actions: v1Action[]
}

function toJSON_1(enduro:Enduro) {
  const TO_ACTION_MAP = {
    [ActionType.SpeedChange]: 'speed',
    [ActionType.FreeTime]: 'freeTime',
    [ActionType.Note]: 'note',
    [ActionType.GasStop]: 'gasStop',
    [ActionType.Reset]: 'reset',
    [ActionType.FreeZone]: 'freeZone',
    [ActionType.ResetToZero]: 'resetTo0',
    [ActionType.Known]: 'known',
    [ActionType.Start]: 'start',
    [ActionType.End]: 'end',
  }

  if (!enduro) return {}

  const routeSheet = enduro.routeSheet;

  const result: v1Route = {
    title: enduro.title,
    keyTime: routeSheet.getKeyTime(),
    options: routeSheet.options,
    actions: []
  };

  result.actions = routeSheet.actions().map((action:Action) => {
    const jsonAction:v1Action = {
      type: {},
      distance: action.distance
    };
    const v1TypeName = TO_ACTION_MAP[action.type]
    console.assert(v1TypeName, `No v1 type matches v2 types ${action.type}`)
    jsonAction.type[TO_ACTION_MAP[action.type]] = true;

    if (jsonAction.type.speed) {
      const speedChange = action as SpeedChange;
      jsonAction.speed = speedChange.speed;
    }
    else if (jsonAction.type.freeTime) {
      const freeTime = action as FreeTime;
      jsonAction.minutes = freeTime.freeTime;
    }
    else if (jsonAction.type.note) {
      const note = action as Note;
      jsonAction.note = note.note;
    }
    else if (jsonAction.type.reset) {
      const reset = action as Reset;
      jsonAction.toDistance = reset.to;
    }
    else if (jsonAction.type.freeZone) {
      const freeZone = action as FreeZone;
      jsonAction.toDistance = freeZone.to;
    }
    return jsonAction
  });

  return result;
}

/**
 * Converts a v1 serialized routesheet into a v2 Enduro which is essentially
 * a v2 serialize routesheet with all computed fields present.
 *
 * @param json JSON object generated by toJSON
 */
function fromJSON_1(json): Enduro {
  // Maps v1 Action names to a function that instantiates an Action.
  const FROM_JSON_MAP:{[index:string]: (a:any) => Action} = {
    'speed':       (a) => new SpeedChange(a.distance, a.speed),
    'freeTime':    (a) => new FreeTime(a.distance, a.minutes),
    'note':        (a) => new Note(a.distance, a.note),
    'gasStop':     (a) => new GasStop(a.distance),
    'reset':       (a) => new Reset(a.distance, a.toDistance),
    'freeZone':    (a) => new FreeZone(a.distance, a.toDistance),
    'resetTo0':    (a) => new ResetTo0(a.distance),
    'known':       (a) => new Known(a.distance),
    'start':       (a) => new Start(a.distance),
    'end':         (a) => new End(a.distance),
  }

  const enduro = new Enduro()
  enduro.title = json?.title ?? ''

  // v1 had no version information
  console.assert(json?.version === undefined, `Invalid routesheet version ${json?.version}`)

  if (json?.actions?.length) {
    // Use first action's speed (must be a speed change)
    console.assert(json.actions[0].type?.speed, 'Initial action not a speed!')
    const routeSheet = new RouteSheet(json.actions[0]?.speed);
    enduro.routeSheet = routeSheet
    enduro.routeSheet.options = json?.options ?? {secretMinSpeed: 6, useSecretMinSpeed: false}

    if (json?.keyTime) {
      routeSheet.setKeyTime(json.keyTime);
    }
    for (let action of json.actions) {
      // First action is always a speed change whose speed change that was
      // created the RouteSheet.constructor so we skip this first action.
      if (action === json.actions[0]) { continue }

      const typeName = Object.keys(action.type)[0]
      const mapEntry = FROM_JSON_MAP[typeName]

      if (!mapEntry) {
        const message = `Unknown JSON action type ${action.type} - skipping`
        debug(message)
        throw new Error(message)
      }
      routeSheet.appendAction(mapEntry(action))
    }
  }

  return enduro;
}

export const Versions = {
  "1": {
    version: {
      number: "1",
      details: "Version 1.0, 2016"
    },
    from: fromJSON_1,
    to: toJSON_1
  },

  "2": {
    version: {
      number: "2",
      details: "Version 2.0, 2021"
    },
    from: fromJSON_2,
    to: toJSON_2
  }
}

export function serializersForJSON(json) {
  return Versions[json?.version ?? "1"]
}

export function toJSON(enduro:Enduro) {
  return toJSON_2(enduro)
}

export function fromJSON(json): Enduro {
  return serializersForJSON(json).from(json)
}
